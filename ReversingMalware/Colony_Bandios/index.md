---
layout: post
title: "Reversing Bandios/Colony Malware"
---

SHA256: [59c662a5207c6806046205348b22ee45da3f685fe022556716dbbd6643e61834](https://www.virustotal.com/#/file/59c662a5207c6806046205348b22ee45da3f685fe022556716dbbd6643e61834)

I found the sample on the [ANY.RUN](https://app.any.run/tasks/1aff9ff2-0b76-45b4-9e3d-b51796b637ad) sandbox.

![1](https://user-images.githubusercontent.com/16405698/38778349-ffb6eab4-40a7-11e8-86d9-50f16359ab02.PNG)

On the `ANY.RUN` sandbox we see that it spawns the child process with `-install` argument, the child process creates several files under `%SYSTEM_DIRECTORY%`:

![2](https://user-images.githubusercontent.com/16405698/38778351-ffdd77b0-40a7-11e8-8918-94348be2875f.png)

If we run the same executable on [hybrid-analysis](https://www.hybrid-analysis.com/sample/59c662a5207c6806046205348b22ee45da3f685fe022556716dbbd6643e61834?environmentId=100) we get almost nothing, it executes recursively and never ends:

![3](https://user-images.githubusercontent.com/16405698/38778331-fca9d084-40a7-11e8-9256-a345df66d5dc.PNG)

Let's dive in deep and see what happens.

`NOTE: I've renamed functions after analysis`

After getting the necessary privileges it checks if `-install` argument is there. if not, it executes `copy_tmp_with_install_arg` and `collect_encrypt_send`, otherwise `iaStorE_and_files` will be executed.

![4](https://user-images.githubusercontent.com/16405698/38778332-fcd2ec30-40a7-11e8-8d20-efd695155432.PNG)

Inside `copy_tmp_with_install_arg` it copies itself to `%TEMP%` directory and executes with the `-install` argument:

![5](https://user-images.githubusercontent.com/16405698/38778333-fd0abb1a-40a7-11e8-8b9a-771c11fa6ef2.PNG)

A very interesting fact is that there are two ways to execute application using the [`CreateProcess`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx) function:

`CreateProcess(exePath, nullptr, ...);` and `CreateProcess(nullptr, exePath, ...);`, if we run the program via the first method we get command line string with quotation marks, otherwise we get one without it:

![create_process_diff](https://user-images.githubusercontent.com/16405698/38778377-571a07be-40a8-11e8-9b9e-7338c00c0274.png)

The sample calls the second variant and at the beginning of the process it checks the arguments without quotation marks, in the normal environment it works as expected but not on the `hybrid-analysis` sandbox. Most likely, `hybrid-analysis` hooks `CreateProcess` at some level and after checking parameters it changes something and passes arguments to lower functions, so, at the end, we get a different command line string, which causes infinite recursion in case of the sample.

We can use this simple technique to bypass `hybrid-analysis` sandbox (`any.run` is immune):

![detect_hybrid_analysis](https://user-images.githubusercontent.com/16405698/38778378-573ddf40-40a8-11e8-8c93-bc38f215cbda.png)

That's the reason why `hybrid-analysis` fails. Let's back to our analysis.

`UPDATE 17.04.2018: The bypass on hybrid-analysis is fixed now`

After executing child process with `-install` parameter, it calls `collect_encrypt_send` function and starts collection information about the system:

Windows version:

![6](https://user-images.githubusercontent.com/16405698/38778334-fd327d80-40a7-11e8-8d9e-a900658c8be0.PNG)

Installed browser:

![7](https://user-images.githubusercontent.com/16405698/38778335-fd57b62c-40a7-11e8-8a92-d8d10ec28be5.PNG)

`NOTE: A clean version of Windows 10 contains HKEY_CURRENT_USER\Software\Google\Chrome key, even if there is no Chrome installed, so this method is not reliable`

Installed AV via checking `HKEY_LOCAL_MACHINE\\SOFTWARE\\%AV_NAME%` key:

![8](https://user-images.githubusercontent.com/16405698/38778336-fd7b9448-40a7-11e8-8969-cf2e7ae15ca5.PNG)

MAC address of the adapter and system language:

![9](https://user-images.githubusercontent.com/16405698/38778337-fda3ab86-40a7-11e8-8899-72be071ffe21.PNG)

It passes the collected information to the `machine_info_AES_base64` function, which encrypts the content with `AES` and encodes with `base64`:

![10](https://user-images.githubusercontent.com/16405698/38778338-fdd23a3c-40a7-11e8-92e3-7e53de520e0a.png)

Inside `machine_info_AES_base64` it calls `CoCreateGuid` to generate 8 bytes of random data and adds another 8 bytes hardcoded value `1Q2a3k79`:

![11](https://user-images.githubusercontent.com/16405698/38778339-fdf7de22-40a7-11e8-9aa1-b6db2cc59390.PNG)

The sample uses `MD5` functions from `advapi32.dll` to calculate the `md5` hash of the abovementioned 16 bytes string (`8_rand_bytes_8_hard_coded`)

![12](https://user-images.githubusercontent.com/16405698/38778340-fe21b526-40a7-11e8-93fc-0839a462d96d.PNG)

After that, it uses the hash as the key to encrypt the system information using `AES` algorithm and encodes the encrypted content via `base64`:

![13](https://user-images.githubusercontent.com/16405698/38778341-fe4e63c8-40a7-11e8-853e-f870241c5c2a.PNG)

`NOTE`: [`IDAScope`](https://bitbucket.org/daniel_plohmann/simplifire.idascope/) plugin for `IDA Pro` is very useful to detect which cryptography algorithms are used in a sample.

It sends the encrypted and encoded data to `iostream.system.band/dump/io/time.php`:

![14](https://user-images.githubusercontent.com/16405698/38778342-fe78fb24-40a7-11e8-8c84-8f0beb073ae7.PNG)


![15](https://user-images.githubusercontent.com/16405698/38778343-fe9d0b9a-40a7-11e8-8415-41e9ae4f0b6f.PNG)

The first 8 bytes are generated by the `CoCreateGuid` call. There is simple code to decrypt the traffic content:

![16](https://user-images.githubusercontent.com/16405698/38778344-fec5aac8-40a7-11e8-964d-164548c4449b.PNG)

<script src="https://gist.github.com/secrary/5266a746928db77a0738ccd15eb67392.js"></script>

After sending system information, the parent process dies, but the child process continues execution with the `-install` argument, and in this case, it executes the `iaStorE_and_files` function.

After calling the [`GetNativeSystemInfo`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724340(v=vs.85).aspx) function, it extracts 32-bit or 64-bit executables based on the `SYSTEM_INFO.dwOemId` field

![17](https://user-images.githubusercontent.com/16405698/38778345-feef026a-40a7-11e8-9254-a1b30e25fbe8.PNG)

After checking the system architecture it calls `write_spoolsr_and_MSdat` and there it decrypts `PE` from `byte_443870`(in case of a `0x64-bit` system) using `0xDD` as the key, generates random `0x40` bytes and appends to the decrypted file, it saves the decrypted file as `%SYS_DIR%\\spoolsr.exe` and the encrypted file as `%SYS_DIR%\\MS.dat`:

![18](https://user-images.githubusercontent.com/16405698/38778346-ff1c0aee-40a7-11e8-9493-b4644da8458f.png)

![19](https://user-images.githubusercontent.com/16405698/38778347-ff506104-40a7-11e8-8fbd-ac8abf87c007.png)

Similarly, `KeyHook_usp20_n_dats`  extract, decrypt and creates following files: `KeyHook64.dll`, `KH.dat`, `usp20.dll` and `UP.dat`:

![20](https://user-images.githubusercontent.com/16405698/38778348-ff8e8538-40a7-11e8-93bc-249ae8469d50.PNG)

![21](https://user-images.githubusercontent.com/16405698/38778379-576208c0-40a8-11e8-9ee9-6e3cd73d62a9.PNG)

`KeyHook64.dll` is decrypted `KH.dat`, `spoolsr.exe` is decrypted `MS.dat` and `usp20.dll` is decrypted `UP.dat`.

After that, it extracts the data from resources (`0x110` in case of `0x64` system and `0x108` otherwise) of the sample and seems like it's encrypted or compressed data:

![22](https://user-images.githubusercontent.com/16405698/38778380-5799d926-40a8-11e8-9344-944346ff8d94.PNG)

And it calls `decompress_` with extracted data and length of the data, `IDAscope` tells us that the function uses `ZLIB`-related constants:

![23](https://user-images.githubusercontent.com/16405698/38778371-5615f83c-40a8-11e8-9eb2-62b8fee0d074.PNG)

![24](https://user-images.githubusercontent.com/16405698/38778372-563e99e0-40a8-11e8-83cc-003903cc1fd1.PNG)

Seems like it's a driver, saved under `C:\Windows\System32\drivers` as `iaStorE.sys`:

![25](https://user-images.githubusercontent.com/16405698/38778374-56670380-40a8-11e8-88ff-53c1467fb06f.PNG)

On a `0x64` system it installs the driver as a crash dump filter by simply adding the drive name to the registry key `\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl\DumpFilters`, on the next reboot, crashdmp.sys will load the filter driver into the dump stack, for more information about `Dump Filer Drivers`, click [here](https://crashdmp.wordpress.com/components/dump-filter-drivers/):

![26](https://user-images.githubusercontent.com/16405698/38778375-5691c93a-40a8-11e8-8220-b31b13ac97f4.png)

On a `0x32` system it installs the driver via creating a service called `iaStorE`:

![27](https://user-images.githubusercontent.com/16405698/38778376-56bd5e1a-40a8-11e8-9f18-b7ebd1468d2e.PNG)

After extracting files and installing the driver, the sample exits.

All files are signed, including drivers, certificates are revoked by its issuer, but that's not a problem for Windows:

![sig](https://user-images.githubusercontent.com/16405698/38778595-7fbd270c-40ab-11e8-9cd2-97e670a24fbf.PNG)


Thank you for your time.

Discuss on [Reddit](https://www.reddit.com/r/ReverseEngineering/comments/8cfjum/reversing_bandioscolony_malware_part_1/)