---
layout: post
title: "Reversing iBank Trojan [Injection Phase]"
---

SHA1: `FA40B39B5E3755A3AB58634DBF0BAF4B0E0E3659`

I've got the sample from [ANY.RUN](https://app.any.run/tasks/43e65ff5-8e87-43d2-95b5-a2350d2c0959), the creation date of the sample is 2011 but it has been uploaded on [VirusTotal](https://www.virustotal.com/#/file/dc8bfa7706730a8518544229ca7714dac4f7c083254741b3d12e5abb42237737/details) just recently. After initial analysis, I've found that it's a variant of banking trojan `iBank`

![1](https://user-images.githubusercontent.com/16405698/37598920-6f7a341a-2b7b-11e8-8185-196bd2022005.PNG)

`NOTE: My recommendation is to open IDA FREE/Pro or any other your favorite disassembler or debugger (x32dbg) inside a VM and analyze the sample with me`

On ANY.RUN we see WHAT the malware does, it injects `Explorer.exe`, `Explorer.exe` itself injects `windanr.exe`, `dwm.exe` and `taskhost.exe`, it also tries to download `key.bin` file from different sources, at this point none of them works.

![2](https://user-images.githubusercontent.com/16405698/37598921-6fa47be4-2b7b-11e8-898a-ae0319ed2080.PNG)

It's WHAT the malware does, let's see HOW it does this.

`NOTE: I've renamed functions after analysis`

![3](https://user-images.githubusercontent.com/16405698/37598892-6a456280-2b7b-11e8-8acd-db16f4336c05.PNG)

At `0x0E22D30` it calls `disable_CaHIPS` to turn off CA HIPS via sending the corresponding request to the `KmxAgent` device:

![4](https://user-images.githubusercontent.com/16405698/37598893-6a7f5b2a-2b7b-11e8-88f1-6182e37e325c.PNG)

At `0x0E22D35` it calls `disableWindowsDefender` to disable `Windows Defender`, you can read more about this method [here](http://seclists.org/fulldisclosure/2008/May/408)

![5](https://user-images.githubusercontent.com/16405698/37598897-6b292696-2b7b-11e8-95d5-1153a52fe623.PNG)

After that, it sends the control message to `____AVP.Root` window, according to `VirusBulletin` [article](https://www.virusbulletin.com/virusbulletin/2010/12/case-study-ibank-trojan
), it's there to block `Kaspersky Anti-Virus`

![6](https://user-images.githubusercontent.com/16405698/37598898-6b4f78d2-2b7b-11e8-9736-a787a960cc01.PNG)

`disableAOutpostFirewall` function uses `Agnitum Outpost firewall` vulnerability and tries to disable the firewall.

![7](https://user-images.githubusercontent.com/16405698/37598900-6b7356da-2b7b-11e8-8be3-1ecec00c5a7f.PNG)

At `AVG_mov_config_file` it renames `dfncfg.dat` to `dfmcfg.dat` and at `zero_AVG_confg_` it removes content of `C:\ProgramData\PrevxCSI\csidb.csi.\AVG9\dfncfg.dat` file, I think it tries to disable `AVG anti-virus`

At `COM_Firewall_add` it uses the COM object to initialize `Windows Firewall with Advanced Security` API (`FirewallAPI.dll`), the API contains functions to manage Windows Firewall settings.

![8](https://user-images.githubusercontent.com/16405698/37598901-6b9e8314-2b7b-11e8-8d74-8c5283756123.PNG)

It Checks if the firewall is enabled and if so, adds itself to the authorized applications list, if you wish you can find more about this method [here](https://web.archive.org/web/20180319072023/https://www.codeproject.com/questions/241336/turn-off-on-firewall):

![9](https://user-images.githubusercontent.com/16405698/37598902-6beff0e6-2b7b-11e8-9691-1a1180566af7.PNG)

If current user is a member of the Administrators group it adds the task to `Task Scheduler` using COM interface and exits, you can find more about COM interface of `Task Scheduler` [here](https://msdn.microsoft.com/en-us/library/windows/desktop/aa383579(v=vs.85).aspx):

![10](https://user-images.githubusercontent.com/16405698/37598904-6c4c60b0-2b7b-11e8-87a8-711b342c22f7.PNG)

![10_task](https://user-images.githubusercontent.com/16405698/37598906-6c8b22f0-2b7b-11e8-8ab0-751b79c4d362.PNG)

If the user is not the admin, it uses `Run` key for persistence and injects into `Explorer.exe`, otherwise injects into `WinLogon.exe`.
To ensure that only one instance of malware runs, it uses `GlobalAddAtomA`/`GlobalFindAtomA` instead of `Mutex`

![11](https://user-images.githubusercontent.com/16405698/37598908-6d408cda-2b7b-11e8-890d-1e142e58f280.PNG)

If the user is admin and path of the malware does not contain `AppPatch` string, it calls `AppPatch_t` function. At `AppPatch_t` it receives the volume serial number of the root directory (in my VM, it's `C:/`), xors it with numbers from 0 to 0xFF, and uses `change_values_encrypt__` function to further modify values, the result is applies as the filename to check if it exists under `Windows Defender` directory

![12_vol_number](https://user-images.githubusercontent.com/16405698/37598910-6dd86cf8-2b7b-11e8-8bc6-8d58513c3fb3.PNG)

![12_weird_path](https://user-images.githubusercontent.com/16405698/37598911-6dfe3488-2b7b-11e8-82cb-e6194e4358c9.PNG)

It copies the malware to `AppPatch/{RandomName}.exe` and uses this name to generate data for `30dfa5f0` key (`30dfa5f0` is volume serial number for my VM) under `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`

![13](https://user-images.githubusercontent.com/16405698/37598913-6e847124-2b7b-11e8-9af0-d9fdef4626aa.PNG)

It sets the creation time of the malware equal to the `NTFS.sys` file
s creation time.

![14](https://user-images.githubusercontent.com/16405698/37598915-6eac6774-2b7b-11e8-83c0-92997db84796.PNG)

If the user is admin it gets `SE_DEBUG_PRIVILEGE` privilege and injects into `winlogon.exe`

![15](https://user-images.githubusercontent.com/16405698/37598916-6ed51f16-2b7b-11e8-9fec-474fa7afeeae.PNG)

The `getProc` function is very simple: it receives a process name and returns the process handle:

![16](https://user-images.githubusercontent.com/16405698/37598917-6effebba-2b7b-11e8-9be5-208fe9c81de6.PNG)

`InjectProc` is also very simple, there are our old friends: `VirtualAllocEx`, `WriteProcessMemory`, more about process injections [here](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process), it uses `CreateRemoteThread` to execute code inside another process, in our case, it's `winlogon.exe` (or `explorer.exe` if the user is not admin)

![17](https://user-images.githubusercontent.com/16405698/37598918-6f2d5e42-2b7b-11e8-848e-51ef1768a5bb.PNG)

`PE_file` is inside the malware, you can dump it from memory or extract from the file, you can use the `Rip` button from [`Exeinfo PE`](http://exeinfo.atwebpages.com/)

![18](https://user-images.githubusercontent.com/16405698/37598919-6f537136-2b7b-11e8-93c5-f988cc9a323a.PNG)

Interesting about the injected file (which is `.dll` by the way), is that it does not have imported functions, which means it somehow gets function addresses.

It uses `PEB` structure of the process to get the base address of `ntdll` module.

![19](https://user-images.githubusercontent.com/16405698/37599119-dde7a158-2b7b-11e8-8076-1d5a33f863c7.PNG)

It uses `getFuncAddr` function to get the address of the desired function, `getFuncAddr` receives two arguments: the base address of the module, and the hash of the function name

![21](https://user-images.githubusercontent.com/16405698/37599121-de307310-2b7b-11e8-8d87-389e36da3abb.PNG)

Pseudocode of the `getFuncAddr` is below, it parses export table of the module and compares the hash of export name with the second argument:

![20](https://user-images.githubusercontent.com/16405698/37599120-de0abff8-2b7b-11e8-827f-0dbae991246c.PNG)

The sample uses `getKernelBase` (0x10001000) to get the address of `kernelbase` module:

![22](https://user-images.githubusercontent.com/16405698/37599122-de884c70-2b7b-11e8-8326-d211be9afe3d.PNG)

So, it has everything it needs to do whatever it wants.

What it does is very similar to the previous stage, but in this case, it allocates memory inside itself and copies the content of another PE file there.

![23](https://user-images.githubusercontent.com/16405698/37599125-deedc5e6-2b7b-11e8-9b7c-cf70033fcc14.PNG)

It parses import table of the second PE, and gets all necessary functions addresses, it builds import table:

![24](https://user-images.githubusercontent.com/16405698/37599128-df5b76b8-2b7b-11e8-878b-a0aa75c3f399.PNG)

After that it jumps recently mapped PE via `call esi`:

![25](https://user-images.githubusercontent.com/16405698/37599129-dfaca8f8-2b7b-11e8-90d5-159699eaf0d0.PNG)

The second PE is also embedded into original PE

![26](https://user-images.githubusercontent.com/16405698/37599130-dfe90622-2b7b-11e8-9d45-c94869416c21.PNG)

I think the second PE have trojan capabilities, but it's outside of the initial injection phase:

![27](https://user-images.githubusercontent.com/16405698/37599118-ddb7ba1a-2b7b-11e8-82be-4621d70c8694.PNG)


Any feedback would be greatly appreciated.

Twitter: [@_qaz_qaz](https://twitter.com/_qaz_qaz)

Discuss on [Reddit](https://www.reddit.com/r/ReverseEngineering/comments/85l5to/reversing_ibank_trojan_injection_phase/)