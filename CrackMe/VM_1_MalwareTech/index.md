---
layout: post
title: "Reverse Engineering simple VM crackme"
---

The `crackme` is created by [@MalwareTechLab](https://twitter.com/MalwareTechLab/status/1001545906066345984), you can download the sample from [here](http://malwaretech.com/downloads/vm1.zip).

We have three files, `vm1.exe`, `ram.bin` and `README.txt`:

![1](https://user-images.githubusercontent.com/16405698/40889213-8794298a-6752-11e8-8e66-b7420dfbeeea.PNG)

click [here](https://user-images.githubusercontent.com/16405698/40889213-8794298a-6752-11e8-8e66-b7420dfbeeea.PNG) for larger version.

`This malware has stolen a flag and encrypted it with a very simple encryption algorithm; unfortunately, the decrypter is coded in a custom 8-bit assembly language which it runs using a minimalistic virtual machine. Your job is to reverse egineer the malware and figure out the instruction set used by the VM, once you've done this you should write your own VM in Python which will run the decrypter and recover the flag.`

Before continue, I recommend you to read the paper [Introduction to Modern Code Virtualization](https://github.com/secrary/sources_from_secrary_posts/files/2066141/Introduction.to.Modern.Code.Virtualization.pdf) and the post [Tutorial for Building and Reverse Engineering Simple Virtual Machine Protection](https://resources.infosecinstitute.com/tutorial-building-reverse-engineering-simple-virtual-machine-protection/), because in this post, I don't explain how `Virtual Machines` and a `Virtulized code` works in general, above-mentioned posts do a great job for introduction.

Let's open the `IDA` and see what we have. The `crackme` copies `0x1FB` bytes from `VM_code` into `VM_ram` (the copied data is the same as `ram.bin` file's content) and calls `VM_run`:

![2](https://user-images.githubusercontent.com/16405698/40889215-87b7a680-6752-11e8-89ea-aa10801e5fbe.PNG)

The following is `Python` implementation of the code fragment:

![3](https://user-images.githubusercontent.com/16405698/40889216-87e06944-6752-11e8-97d5-043f71f88c25.PNG)

Inside `VM_run`, it fetches `opcode` and two operands and calls `VM_decode`. As we see it fetches `opcode` from the second part of `VM_ram` (actually from `VM_ram + 0xff`), we can guess that code section starts from there.

NOTE: For example, in `MOV eax, 1` instruction, `MOV` is opcode, `eax` and `1` are operands.

![4](https://user-images.githubusercontent.com/16405698/40889208-86d98c2e-6752-11e8-99b6-9906cb7670d5.PNG)

`Python` implementation:

![5](https://user-images.githubusercontent.com/16405698/40889209-8702352a-6752-11e8-8525-424be27a3a5c.PNG)

`VM_decode` executes a different code block based on the fetched `opcode`:

![6](https://user-images.githubusercontent.com/16405698/40889210-87256fae-6752-11e8-908e-ad4aa1138af0.PNG)

click [here](https://user-images.githubusercontent.com/16405698/40889210-87256fae-6752-11e8-908e-ad4aa1138af0.PNG) for larger version.

* If `opcode` is 1, it writes the second `operand` to the data section at position pointed by the first `operand` (`MOV VM_data[operand_1], operand_2`).

* If `opcode` is 2, it saves the data pointed by the first `operand` into the global variable, I renamed it as `R0` - register 0 (`MOV R0, operand_2`).

* If `opcode` is 3, it `XORs` data pointed by the first `operand` with `R0` (`XOR VM_data[operand_1], R0`).

That's whole instruction set, so simple.

`Python` implementation of `VM_decode` function:

![7](https://user-images.githubusercontent.com/16405698/40889211-874d8d72-6752-11e8-8298-9a14eba610d9.PNG)

That's all, we know that the first part of the `ram.bin` file is data section, the second one is code section and we have just three instructions.

After running the `Python` implementation, we get the flag: `FLAG{VMS-ARE-FOR-MALWARE}`

![8](https://user-images.githubusercontent.com/16405698/40889212-876fc608-6752-11e8-958d-29baed02afc9.PNG)

Whole `Python` script:

<script src="https://gist.github.com/secrary/0f043b80a106706bc88f928ba58e7793.js"></script>